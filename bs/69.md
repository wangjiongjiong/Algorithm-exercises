## [x 的平方根](https://leetcode.cn/problems/sqrtx/)



给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

 

**提示：**

- `0 <= x <= 231 - 1`

### 思路

这个题起初我在拿到手里时，并没有觉得跟二分查找有什么关系，这道题我第一次进行思考完全想不到，与二分查找有什么关系，所以第一次我使用的是暴力求解方法这里我先给出代码。

```c++
class Solution 
{
public:
    int mySqrt(int x) 
    {
        int n = 0;
        if(x == 0)
        {
            return 0;
        }
        while (n*n<=x)
        {
            if(n*n<=x && (n+1)*(n+1)>x)
            {
                return n;
            }
            n++;
        }
        return n;
    }
};
```

暴力求解的话思想就很简单的，就是设定一个计数的n循环条件的得话就是n的平方值小于等于`x`就就进行循环，这里条件就很简单了`n`的平方小于等于`x`并且`n+1`的平方大于x这时候很明显，`n`就是`x`平方根的整数部分，因此此时返回`n`。这种方法对于`x`值小的时候确实效率还可以但是思考一下，如果`x`的值很大那么这种暴力方法就不是很好了吧。而且这里有一个小坑就是当你的x足够大时，`n`的平方和`n+1`的平方这块需要进行类型转换以为此时`int`类型的大小已经不够了所以这里需要使用`long long`类型。

在思考了一段时间后，我在想为什么这个题会放到二分查找里面，看了题解后恍然大悟，其实这个题就是让我们找一个n使得`n^2<x`，那么我们为什么不能将`0-x`看成一个有序数组呢，在这个有序数组里面我们找到一个n使得n是x的算数平方根的整数部分。这里先给代码。

```c++
class Solution 
{
public:
    int mySqrt(int x) 
    {
        int left , right , middle;
        left = 0;
        right = x;
        int res = 0;
        while (left<=right)
        {
            middle = left + (right-left)/2;
            if((long long)middle*middle<=x)
            {
                res = middle;
                left = middle + 1;
            }
            else
            {
                right = middle - 1;
            }
        }
        return res;
    }
};
```

主要思考的地方就是为什么条件哪里写小于等于，很简单因为对于n来说n是x平方根的整数部分因此，n的平方是一定小于x的，因此如果我们在对大于进行n的赋值时得出的n就会大一位并且当x为0和1时候还是特殊情况，因此代码就会的繁琐。

这道题目还有两种比较数学的方法一种是利用指数函数的思想，而另一种利用牛顿迭代法的思想这两种思想比较数学化，一般我们就不去考虑了，后续如果感兴趣可以看一看。