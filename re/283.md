[283.移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**进阶：**你能尽量减少完成的操作次数吗？

### 方法一，双指针

双指针思想已经比较熟悉了，其本质就是我们设置两个指针一个是快指针，一个是慢指针。慢指针开始指向数组的第一位，快指针也指向，数组第一位，当快指针走到数组尾部是算法退出，每次快指针需要进行判断，判断快指针指向的数组值是否为0若不为0则将快慢指针指向的值进行交换，然后慢指针指向下一位，这样我们的慢指针始终指向0，但是思考如果第一位是0的时候满足吗，显然是满足的，因为当第一位非0时我们第一次循环就会进行交换由于此时快慢指针指向同一个值因此交换也不会发生改变同时此时快慢指针都向后移动以为直到，当遇到第一个0的时候慢指针停止，快指针开始寻找非0元素进行交换。

```c++
void moveZeroes1(vector<int>& nums) 
    {
        //双指针思想
        int size = nums.size();
        int fast = 0 , low = 0;
        while (fast < size)
        {
            if(nums[fast] != 0)
            {
                std::swap(nums[fast],nums[low]);
                low++;
            }
            fast++;
        }
    }
```

还有一种类似于双指针的方法，但是代码更简洁。

```c++
void moveZeroes3(vector<int>& nums) 
    {
        //快速排序思想,类似双指针但是更简洁
        int left = 0;
        int size = nums.size();
        for(int i = 0; i<size;++i)
        {
            if(nums[i] != 0)
            {
                std::swap(nums[left],nums[i]);
                left++;
            }
        }
    }
```



### 方法二，暴力解法

暴力解法很简单就是利用两个循环解决，第一次循环我们寻找到非0元素，并从数组首位开始填充，这样我们一次循环就找到了所有的非0元素并且不改变元素的相对位置。第二次循环我们将数组剩余位置全置为0即可。但是这个方法的时间复杂度比较高，相对于双指针方法来说不太好。

```c++
void moveZeroes2(vector<int>& nums) 
    {
        //两次遍历
        int j = 0;
        for(int i = 0; i<nums.size();++i)
        {
            if(nums[i] != 0)
            {
                nums[j] = nums[i];
                ++j;
            }
        }
        for(int k = j;k<nums.size();++k)
        {
            nums[k] = 0;
        }
    }
```

